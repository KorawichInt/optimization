# -*- coding: utf-8 -*-
"""งาน#3 River_Formation_Dynamics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D8jW3i6mcqUcPhUXcJdH8FjT5paW74Yc

# ทำ distance matrix
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install haversine

import pandas as pd
import haversine as hs
from haversine import Unit
import numpy as np
import random
import matplotlib.pyplot as plt

df = pd.read_csv("provinces.csv")
lat = df["province_lat"]
lng = df["province_lon"]
my_distance = []
for i1, i2 in zip(lat, lng):
    distances = []
    for j1, j2 in zip(lat, lng):
        distances.append(hs.haversine((i1, i2), (j1, j2), unit=Unit.KILOMETERS))
    my_distance.append(distances)

for i in my_distance:
  print(i)

"""# ฟังก์ชันสำหรับการคำนวณระยะทาง"""

# ส่งค่าระยะทางระหว่างเมือง
def calculate_distance(city1, city2):
    return my_distance[city1][city2]


# คำนวณความยาวของเส้นทางที่เดินผ่าน
def total_route_distance(route):
    distance = 0
    for i in range(len(route) - 1):
        distance += calculate_distance(route[i], route[i + 1])
    distance += calculate_distance(route[-1], route[0])  # กลับไปยังเมืองเริ่มต้น
    return distance

num_cities = len(my_distance)

# ตารางที่เก็บปริมาณ "น้ำ" (น้ำแสดงถึงความนิยมในการเลือกเส้นทาง)
global water_levels
water_levels = np.zeros((num_cities, num_cities))

# ตารางที่เก็บระดับความสูงของภูมิประเทศ (สูงสุดเริ่มต้นที่ 1)
global height_levels
height_levels = np.ones((num_cities, num_cities))

water_drop=10
erosion_rate=0.05

"""# ฟังก์ชันย่อย"""

def flow_water(route):
    global water_levels, height_levels
    for i in range(len(route) - 1):
        water_levels[route[i], route[i + 1]] += water_drop
        height_levels[route[i], route[i + 1]] -= erosion_rate  # กัดเซาะเส้นทาง
    water_levels[route[-1], route[0]] += water_drop
    height_levels[route[-1], route[0]] -= erosion_rate  # กัดเซาะเส้นทาง

# การหาทางที่ดีที่สุดตามระดับน้ำและระดับความสูงที่มีอยู่
def find_route():
    global water_levels, height_levels
    route = [56]  # เริ่มต้นจากเมืองสุ่มเมืองหนึ่ง
    while len(route) < num_cities:
        current_city = route[-1]
        remaining_cities = list(set(range(num_cities)) - set(route))
        # คำนวณความน่าจะเป็น
        probabilities = [
            (
                (
                    water_levels[current_city, next_city]
                    / height_levels[current_city, next_city]
                )
                if height_levels[current_city, next_city] > 0
                else 0
            )
            for next_city in remaining_cities
        ]
        # ตรวจสอบว่าความน่าจะเป็นรวมเป็นศูนย์หรือไม่
        total_probability = sum(probabilities)
        if total_probability == 0:
            next_city = random.choice(remaining_cities)  # ใช้การเลือกแบบสุ่ม
        else:
            # ทำให้ความน่าจะเป็นอยู่ในรูปแบบที่สามารถใช้ได้
            probabilities = [p / total_probability for p in probabilities]
            next_city = random.choices(
                remaining_cities, weights=probabilities, k=1
            )[0]
        route.append(next_city)
    return route

"""# ฟังก์ชันหลัก

"""

def rfd_tsp(
    num_iterations=1000
):

    best_route = []
    best_distance = 1000000
    all_distance = []
    # วนลูปหลักของอัลกอริธึม
    for iteration in range(num_iterations):
        new_route = find_route()  # หาเส้นทางใหม่ตามระดับน้ำและระดับความสูง
        new_distance = total_route_distance(new_route)

        # ถ้าเส้นทางใหม่ดีกว่า ให้เลือกเส้นทางนั้น และให้ "น้ำ" ไหลในเส้นทางนั้น
        if new_distance < best_distance:
            best_route = new_route
            best_distance = new_distance
        all_distance.append(best_distance)

        # ปล่อยให้น้ำไหลในเส้นทางที่พบ พร้อมกัดเซาะเส้นทาง
        flow_water(new_route)

        # แสดงผลทุก ๆ 100 รอบ
        if iteration % 100 == 0:
            print(f"Iteration {iteration}: Best Distance = {best_distance},\nBest Route = {best_route}\n")

    return best_route, best_distance, all_distance

"""# เริ่มต้นการทำงาน"""

best_route, best_distance, cost = rfd_tsp()

plt.plot(cost, c="r")
plt.xlabel("Iteration")
plt.ylabel("Cost")
plt.legend(["RFD Cost", "Opt"], loc="upper right")
plt.show()